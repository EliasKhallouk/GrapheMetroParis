Graphe Métro Paris — Rapport Technique

1. Présentation générale
Ce projet implémente une application web de calcul d’itinéraires sur le réseau du métro parisien. Il charge un graphe (stations et temps de trajet), fournit des endpoints API en Flask et une interface web interactive (HTML/CSS/JS) pour visualiser les stations, calculer le plus court chemin, et générer l’arbre couvrant de poids minimal (ACPM).

2. Travail effectué
- Parsing des fichiers de données: `Data/metro.txt` pour les stations et les temps de trajet, `Data/pospoints.txt` pour les coordonnées approximatives.
- Construction d’un graphe en mémoire (stations, arêtes non orientées pondérées par le temps).
- Implémentation du calcul du plus court chemin (Bellman-Ford) et du calcul d’un arbre couvrant minimal (Prim).
- Exposition d’API REST avec Flask: `/stations`, `/station/<id>`, `/graph`, `/path`, `/mst`, `/health`.
- Frontend interactif: chargement des stations, dessin du plan, tracé des chemins et de l’ACPM, affichage du narratif d’itinéraire.
- Ajout d’un texte narratif structuré pour les directions (style francophone avec correspondances et estimations en minutes).
- Affichage du poids total de l’ACPM côté API et frontend.

3. Structures de données choisies
- Station (dataclass Python):
  - id (int), name (str), line (str), terminus (bool), branch (int), x/y (Optional[int])
- MetroGraph:
  - stations: Dict[int, Station]
  - adj: Dict[int, List[Tuple[int, int]]] — liste d’adjacence avec couples (voisin, temps)
Ces structures sont simples, efficaces pour des parcours (BFS/DFS), Bellman-Ford, et Prim, et adaptées à un graphe non orienté pondéré.

4. Principales procédures
- Chargement du graphe
  - `_parse_metro(path)`: lit `metro.txt`, extrait les stations (lignes V) et arêtes (lignes E). Les arêtes sont stockées des deux côtés (non orienté) avec temps entier.
  - `_parse_positions(path)`: lit `pospoints.txt` et affecte x/y aux stations correspondantes.
- Plus court chemin
  - `shortest_path(start, end)`: Bellman-Ford sur graphe non orienté, reconstruit le chemin via le tableau des précédents; retourne (temps total, liste des ids).
- Arbre couvrant minimal
  - `prim_mst()`: Prim classique, construit un ACM par composant si non connexe; retourne la liste des arêtes (u, v, poids).
- API Flask
  - `/stations`: liste enrichie des stations (lignes au même nom, terminus, branch, coordonnées).
  - `/station/<id>`: détails d’une station et de ses voisins.
  - `/graph`: export JSON des stations et arêtes.
  - `/connected`: booléen de connexité.
  - `/mst`: arêtes de l’ACPM + `total_weight`.
  - `/path`: plus court chemin, stations détaillées, et un `narrative` en français.

5. Méthode algorithmique et justification
- Bellman-Ford pour le plus court chemin:
  - Adapté aux graphes pondérés, simple à implémenter, et robuste même si des arêtes négatives existaient (ce n’est pas le cas ici). Sur un graphe de taille modérée, son coût O(V*E) reste acceptable.
  - Justification: la simplicité et l’absence de dépendances externes. Dijkstra (avec tas) serait plus performant sur des poids non négatifs; Bellman-Ford a été choisi pour sa clarté pédagogique.
- Prim pour l’ACPM:
  - Adapté aux graphes non orientés pondérés pour construire un arbre couvrant minimal en O(E log V) avec tas; justification: standard, efficace, et facile à visualiser sur le plan.

6. Contrat d’API (résumé)
- `GET /path?start=<id>&end=<id>` → JSON { total_time_seconds, path:[ids], stations:[{id,name,line,lines_at_name}], narrative:str }
- `GET /mst` → JSON { edges:[{from,to,time}], count:int, total_weight:int }
- `GET /stations` → JSON [ { id,name,line,lines_at_name,terminus,branch,x,y } ]

7. Lancement de l’application
Prérequis: Python 3.10+ recommandé.
- Créer un environnement virtuel (optionnel mais conseillé):
  - Linux/macOS:
    1) `python -m venv .venv`
    2) `source .venv/bin/activate`
  - Windows (PowerShell):
    1) `python -m venv .venv`
    2) `.venv\Scripts\Activate.ps1`
- Installer les dépendances:
  1) `pip install -r requirements.txt`
- Lancer le serveur:
  1) `python run.py`
- Ouvrir le navigateur sur: `http://127.0.0.1:5000/`

8. Dépendances et installation
- Fichier `requirements.txt` (principales):
  - Flask: serveur web léger pour l’API et la page.
- Installation:
  - `pip install -r requirements.txt`
- Aucune base de données requise; tout est chargé en mémoire à partir de `Data/`.

9. Organisation des fichiers
- `app/graph.py`: structure du graphe, parsing des fichiers, algorithmes Bellman-Ford et Prim, utilitaires.
- `app/api.py`: endpoints Flask, sérialisation des données, construction du narratif.
- `static/index.html`: interface web.
- `static/css/style.css`, `static/css/responsive.css`: styles et responsive.
- `static/js/app.js`: logique front (chargement, dessin canvas, notifications, MST, chemin, narratif).
- `Data/`: fichiers de données (`metro.txt` et `pospoints.txt`).
- `run.py`: point d’entrée pour lancer le serveur.
- `README.md`: documentation rapide.

10. Limites et pistes d’amélioration
- Orienter la “direction” vers le terminus réellement correspondant au sens de parcours (nécessiterait la topologie par ligne).
- Pénalité de correspondance et multi-critères (minimiser à la fois temps et changements).
- Mise en cache des chemins fréquents et affichage détaillé par ligne.
- Dijkstra avec tas pour des performances meilleures sur grands réseaux.

11. Tests rapides
- API: `GET /health`, `GET /stations`, `GET /connected`, `GET /mst`, `GET /path?start=<id>&end=<id>`.
- Front: sélectionner départ et arrivée, calculer l’itinéraire, vérifier le narratif, tracer le chemin, afficher l’ACPM et le poids total.

Ce rapport est volontairement concis (<10 pages) et couvre la conception, l’implémentation, l’algorithme, le lancement, et les dépendances.
